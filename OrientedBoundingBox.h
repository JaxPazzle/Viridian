//AxisAlignedBoundingBox.h
//Jacqueline Passehl Winter Quarter 2k16

#ifndef _OrientedBoundingBox
#define _OrientedBoundingBox

#include "MathTools.h"
#include "AzulCore.h"
#include "CollisionVolume.h"

class BoundingSphere;
class Visualizer;
class TerrainCell;

class OrientedBoundingBox :public CollisionVolume, public Align16
{
private:

	//data points:
	//min on x/y/z
	Vect min;
	//max on x/y/z
	Vect max;
	Vect center;

	Matrix world;
	Visualizer* visualizeHelper;


	Vect halfDiagonal;
	float SquaredScaleFactor;


	MathTools mathTools;
	AxisAlignedBoundingBox* ptrAABB;


public:

	float minX;
	float minY;
	float minZ;
	float maxX;
	float maxY;
	float maxZ;


	OrientedBoundingBox();
	~OrientedBoundingBox(){};
	OrientedBoundingBox& operator=(const OrientedBoundingBox&) = delete;


	//scan all vertices of the model, for each vertex apply world transform
	
	////////////////////////////////////////////////////////////////////////////////////////////////////
	/// @defgroup OrientedBoundingBox OrientedBoundingBox
	///  @ingroup CollisionSystem
	///	  @brief The OrientedBoundingBox (OBBB) Collision Volume
	////////////////////////////////////////////////////////////////////////////////////////////////////
	/** @{ */


	////////////////////////////////////////////////////////////////////////////////////////////////////
	/// <summary>	Calculates the data. </summary>
	///
	/// <param name="model"> 	The model. </param>
	/// <param name="matrix">	The matrix. </param>
	////////////////////////////////////////////////////////////////////////////////////////////////////

	void ComputeData(const Model* model, const Matrix &matrix);

	////////////////////////////////////////////////////////////////////////////////////////////////////
	/// <summary>	Initalizes the given model. </summary>
	///
	/// <param name="model">	The model. </param>
	////////////////////////////////////////////////////////////////////////////////////////////////////

	void Initalize(const Model* model);

	////////////////////////////////////////////////////////////////////////////////////////////////////
	/// <summary>	Intersects the given obb 2. </summary>
	///
	/// <param name="OBB2">	 the second obb. </param>
	///
	/// <returns>	true if it succeeds, false if it fails. </returns>
	////////////////////////////////////////////////////////////////////////////////////////////////////

	virtual bool Intersect(OrientedBoundingBox* OBB2) override;

	////////////////////////////////////////////////////////////////////////////////////////////////////
	/// <summary>	Intersects the given b sphere. </summary>
	///
	/// <param name="bSphere">	 the sphere. </param>
	///
	/// <returns>	true if it succeeds, false if it fails. </returns>
	////////////////////////////////////////////////////////////////////////////////////////////////////

	bool Intersect(BoundingSphere* bSphere);

	////////////////////////////////////////////////////////////////////////////////////////////////////
	/// <summary>	Intersects the given aabb. </summary>
	///
	/// <param name="AABB">	 the AABB. </param>
	///
	/// <returns>	true if it succeeds, false if it fails. </returns>
	////////////////////////////////////////////////////////////////////////////////////////////////////

	bool Intersect(AxisAlignedBoundingBox* AABB);

	////////////////////////////////////////////////////////////////////////////////////////////////////
	/// <summary>	Intersects the given other collision volume. </summary>
	///
	/// <param name="other">	the other volume to be collided with. </param>
	///
	/// <returns>	true if it succeeds, false if it fails. </returns>
	////////////////////////////////////////////////////////////////////////////////////////////////////

	bool Intersect( CollisionVolume* other);

	////////////////////////////////////////////////////////////////////////////////////////////////////
	/// <summary>	Intersects the given terrain cell </summary>
	///
	/// <param name="other">	the cell. </param>
	///
	/// <returns>	true if it succeeds, false if it fails. </returns>
	////////////////////////////////////////////////////////////////////////////////////////////////////

	bool Intersect(TerrainCell* other);


	/// <summary>	Calculates the corners. </summary>
	void ComputeCorners();

	////////////////////////////////////////////////////////////////////////////////////////////////////
	/// <summary>	Renders this OBB. </summary>
	///
	/// <param name="color">	The color. </param>
	////////////////////////////////////////////////////////////////////////////////////////////////////

	virtual void RenderThis(const Vect& color);

	////////////////////////////////////////////////////////////////////////////////////////////////////
	/// <summary>	Gets the mininum in local space. </summary>
	///
	/// <returns>	The calculated minimum. </returns>
	////////////////////////////////////////////////////////////////////////////////////////////////////

	Vect GetMin();

	////////////////////////////////////////////////////////////////////////////////////////////////////
	/// <summary>	Gets the maximum in local space. </summary>
	///
	/// <returns>	The calculated maximum. </returns>
	////////////////////////////////////////////////////////////////////////////////////////////////////

	Vect GetMax();

	////////////////////////////////////////////////////////////////////////////////////////////////////
	/// <summary>	Gets world matrix. </summary>
	///
	/// <returns>	The world matrix. </returns>
	////////////////////////////////////////////////////////////////////////////////////////////////////

	Matrix GetWorldMatrix();

	////////////////////////////////////////////////////////////////////////////////////////////////////
	/// <summary>	Gets half diagonal. </summary>
	///
	/// <returns>	The half diagonal. </returns>
	////////////////////////////////////////////////////////////////////////////////////////////////////

	Vect GetHalfDiagonal();

	////////////////////////////////////////////////////////////////////////////////////////////////////
	/// <summary>	Gets the center. </summary>
	///
	/// <returns>	The center. </returns>
	////////////////////////////////////////////////////////////////////////////////////////////////////

	Vect GetCenter();

	////////////////////////////////////////////////////////////////////////////////////////////////////
	/// <summary>	Gets squared scale factor. </summary>
	///
	/// <returns>	The squared scale factor. </returns>
	////////////////////////////////////////////////////////////////////////////////////////////////////

	float GetSquaredScaleFactor();
	/** @} */
};
#endif _OrientedBoundingBox